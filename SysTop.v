// File: SysTop.v
// Generated by MyHDL 0.10
// Date: Sat Jan 19 13:38:33 2019


`timescale 1ns/10ps

module SysTop (
    txd_line,
    rxd_line,
    txd_line2,
    rxd_line2,
    leds,
    reset,
    clock
);


output txd_line;
reg txd_line;
input rxd_line;
output txd_line2;
reg txd_line2;
input rxd_line2;
output [7:0] leds;
reg [7:0] leds;
input reset;
input clock;

reg rx_avail2;
reg [31:0] led_reg;
reg [31:0] dmem_data_in;
wire dmem_we_out;
reg write_en;
reg [3:0] dmem_sel;
reg [31:0] rx_data2;
reg uart_rxd;
reg [31:0] led_low;
wire [31:0] tx_data2;
reg rx_error2;
reg rx_avail;
reg [31:0] imem_data_in;
reg dmem_ena;
reg uart_rxd2;
reg [19:0] count;
wire tx_busy;
reg [31:0] tx_data;
reg dmem_ena_in;
reg [31:0] rx_data;
reg read_en2;
reg rx_error;
reg read_en;
reg uart_txd2;
wire [31:0] dmem_addr_out;
wire imem_ena_out;
reg uart_txd;
wire dmem_ena_out;
reg [31:0] imem_data_out;
wire [31:0] dmem_data_out;
wire [3:0] dmem_sel_out;
wire [15:0] imem_addr_out;
wire tx_busy2;
wire write_en2;
reg [3:0] imem_sel_out;
reg [3:0] uart2_rx_bitcount;
wire uart2_enable16;
reg [3:0] uart2_tx_bitcount;
reg [15:0] uart2_enable16_counter;
reg uart2_uart_rxd1;
reg uart2_uart_rxd2;
reg [3:0] uart2_tx_count16;
reg [8:0] uart2_txd_reg;
reg uart2_rx_is_busy;
reg [7:0] uart2_rxd_reg;
reg [3:0] uart2_rx_count16;
reg uart2_tx_is_busy;
reg [3:0] uart_rx_bitcount;
wire uart_enable16;
reg [3:0] uart_tx_bitcount;
reg [15:0] uart_enable16_counter;
reg uart_uart_rxd1;
reg uart_uart_rxd2;
reg [3:0] uart_tx_count16;
reg [8:0] uart_txd_reg;
reg uart_rx_is_busy;
reg [7:0] uart_rxd_reg;
reg [3:0] uart_rx_count16;
reg uart_tx_is_busy;
reg core_of_reg_write;
reg core_of_mem_write;
reg [31:0] core_gprf_dat_a;
reg [1:0] core_of_alu_src_b;
reg [1:0] core_of_transfer_size;
reg [31:0] core_mm_alu_result;
reg [4:0] core_of_fwd_reg_d;
reg [1:0] core_of_carry;
reg [1:0] core_ex_transfer_size;
reg [15:0] core_of_program_counter;
reg [4:0] core_mm_reg_d;
reg core_of_fwd_reg_write;
reg [1:0] core_of_alu_src_a;
reg core_ex_branch;
reg core_mm_mem_read;
reg [31:0] core_gprf_dat_b;
reg core_of_delay;
reg [31:0] core_of_fwd_mem_result;
reg [31:0] core_gprf_dat_d;
reg [1:0] core_mm_transfer_size;
reg core_of_mem_read;
reg [15:0] core_ex_program_counter;
wire [15:0] core_if_program_counter;
wire core_ex_reg_write;
reg [31:0] core_ex_dat_d;
reg [4:0] core_of_reg_d;
reg core_ex_flush_id;
reg [4:0] core_of_reg_a;
reg [4:0] core_of_reg_b;
reg core_of_operation;
reg core_ex_mem_write;
wire [31:0] core_ex_alu_result;
reg core_ex_mem_read;
reg [31:0] core_of_immediate;
reg core_mm_reg_write;
reg [2:0] core_of_branch_cond;
wire [4:0] core_ex_reg_d;
reg [3:0] core_of_alu_op;
reg core_of_carry_keep;
reg core_of_hazard;
reg [31:0] core_memu_mm_comb_alu_result;
reg core_memu_mm_comb_reg_write;
reg [1:0] core_memu_mm_comb_transfer_size;
reg [31:0] core_memu_mem_result;
reg [4:0] core_memu_mm_comb_reg_d;
reg core_memu_mm_comb_mem_read;
reg core_exeu_ex_comb_mem_read;
reg core_exeu_ex_r_flush_ex;
reg [1:0] core_exeu_ex_comb_transfer_size;
reg core_exeu_ex_comb_r_flush_ex;
reg core_exeu_ex_r_reg_write;
reg [4:0] core_exeu_ex_r_reg_d;
reg core_exeu_ex_comb_flush_id;
reg core_exeu_ex_comb_r_carry;
reg [31:0] core_exeu_ex_comb_r_alu_result;
reg [4:0] core_exeu_ex_comb_r_reg_d;
reg core_exeu_ex_comb_branch;
reg [31:0] core_exeu_ex_r_alu_result;
reg [31:0] core_exeu_ex_comb_dat_d;
reg core_exeu_ex_comb_mem_write;
reg core_exeu_ex_r_carry;
reg [15:0] core_exeu_ex_comb_program_counter;
reg core_exeu_ex_comb_r_reg_write;
reg [4:0] core_deco_of_r_reg_d;
reg [31:0] core_deco_of_comb_r_instruction;
reg [31:0] core_deco_of_comb_immediate;
reg core_deco_of_comb_reg_write;
reg core_deco_of_comb_carry_keep;
reg [15:0] core_deco_of_r_immediate_high;
reg [1:0] core_deco_of_comb_transfer_size;
reg [3:0] core_deco_of_comb_alu_op;
reg [4:0] core_deco_of_comb_reg_a;
reg [1:0] core_deco_of_comb_carry;
reg core_deco_of_comb_r_mem_read;
reg [1:0] core_deco_of_comb_alu_src_b;
reg core_deco_of_r_mem_read;
reg [15:0] core_deco_of_comb_r_immediate_high;
reg [1:0] core_deco_of_comb_alu_src_a;
reg core_deco_of_r_has_imm_high;
reg [31:0] core_deco_wb_dat_d;
reg core_deco_of_comb_mem_write;
reg [15:0] core_deco_of_r_program_counter;
reg core_deco_of_comb_delay;
reg core_deco_of_comb_r_hazard;
reg [15:0] core_deco_of_comb_program_counter;
reg [15:0] core_deco_of_comb_r_program_counter;
reg [2:0] core_deco_of_comb_branch_cond;
reg [31:0] core_deco_of_r_instruction;
reg [4:0] core_deco_of_comb_r_reg_d;
reg [4:0] core_deco_of_comb_reg_b;
reg core_deco_of_comb_r_has_imm_high;
reg core_deco_of_r_hazard;
reg core_deco_of_comb_operation;
reg [15:0] core_ftch_if_comb_r_program_counter;
reg [15:0] core_ftch_if_r_program_counter;
reg [29:0] dmem_bank_addr;
reg [13:0] imem_bank_addr;
reg [31:0] core_deco_gprf_d_ram [0:32-1];
reg [31:0] core_deco_gprf_b_ram [0:32-1];
reg [31:0] core_deco_gprf_a_ram [0:32-1];
reg [7:0] dmem_bank_in [0:4-1];
reg [7:0] dmem_bank_out [0:4-1];
reg dmem_bank_wre [0:4-1];
reg [7:0] dmem_bank_3_ram [0:2048-1];
reg [7:0] dmem_bank_2_ram [0:2048-1];
reg [7:0] dmem_bank_1_ram [0:2048-1];
reg [7:0] dmem_bank_0_ram [0:2048-1];
reg [7:0] imem_bank_in [0:4-1];
reg [7:0] imem_bank_out [0:4-1];
reg imem_bank_wre [0:4-1];
reg [7:0] imem_bank_3_ram [0:2048-1];
reg [7:0] imem_bank_2_ram [0:2048-1];
reg [7:0] imem_bank_1_ram [0:2048-1];
reg [7:0] imem_bank_0_ram [0:2048-1];

assign tx_data2 = 32'd0;
assign write_en2 = 1'd0;

function [32-1:0] MYHDL24_align_mem_load;
    input [32-1:0] data;
    input [2-1:0] size;
    input [32-1:0] address;
    reg [32-1:0] result;
begin: MYHDL78_RETURN
    result = 32'h0;
    case (size)
        2'b10: begin
            if ((address[1] == 0)) begin
                if ((address[0] == 0)) begin
                    result = data[32-1:24];
                end
                else begin
                    result = data[24-1:16];
                end
            end
            else begin
                if ((address[0] == 0)) begin
                    result = data[16-1:8];
                end
                else begin
                    result = data[8-1:0];
                end
            end
        end
        2'b01: begin
            if ((address[1] == 0)) begin
                result = data[32-1:16];
            end
            else begin
                result = data[16-1:0];
            end
        end
        default: begin
            result = data;
        end
    endcase
    MYHDL24_align_mem_load = result;
    disable MYHDL78_RETURN;
end
endfunction

function [32-1:0] MYHDL25_sign_extend16;
    input [16-1:0] value;
    input fill;
    reg [32-1:0] tmp;
    integer i;
    integer size;
begin: MYHDL79_RETURN
    tmp = 32'h0;
    size = (32 - 16);
    for (i=0; i<size; i=i+1) begin
        tmp[((32 - 1) - i)] = fill;
    end
    tmp[16-1:0] = value[16-1:0];
    MYHDL25_sign_extend16 = tmp;
    disable MYHDL79_RETURN;
end
endfunction

function MYHDL29_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL80_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL29_forward_condition = result;
    disable MYHDL80_RETURN;
end
endfunction

function [32-1:0] MYHDL30_select_register_data;
    input [32-1:0] reg_dat;
    input [5-1:0] reg_x;
    input [32-1:0] wb_dat;
    input write;
    reg [32-1:0] tmp;
begin: MYHDL81_RETURN
    tmp = 32'h0;
    if ((reg_x == 0)) begin
        tmp = 0;
    end
    else if (write) begin
        tmp = wb_dat;
    end
    else begin
        tmp = reg_dat;
    end
    MYHDL30_select_register_data = tmp;
    disable MYHDL81_RETURN;
end
endfunction

function MYHDL31_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL82_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL31_forward_condition = result;
    disable MYHDL82_RETURN;
end
endfunction

function [32-1:0] MYHDL32_select_register_data;
    input [32-1:0] reg_dat;
    input [5-1:0] reg_x;
    input [32-1:0] wb_dat;
    input write;
    reg [32-1:0] tmp;
begin: MYHDL83_RETURN
    tmp = 32'h0;
    if ((reg_x == 0)) begin
        tmp = 0;
    end
    else if (write) begin
        tmp = wb_dat;
    end
    else begin
        tmp = reg_dat;
    end
    MYHDL32_select_register_data = tmp;
    disable MYHDL83_RETURN;
end
endfunction

function MYHDL33_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL84_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL33_forward_condition = result;
    disable MYHDL84_RETURN;
end
endfunction

function [32-1:0] MYHDL34_select_register_data;
    input [32-1:0] reg_dat;
    input [5-1:0] reg_x;
    input [32-1:0] wb_dat;
    input write;
    reg [32-1:0] tmp;
begin: MYHDL85_RETURN
    tmp = 32'h0;
    if ((reg_x == 0)) begin
        tmp = 0;
    end
    else if (write) begin
        tmp = wb_dat;
    end
    else begin
        tmp = reg_dat;
    end
    MYHDL34_select_register_data = tmp;
    disable MYHDL85_RETURN;
end
endfunction

function [32-1:0] MYHDL35_align_mem_load;
    input [32-1:0] data;
    input [2-1:0] size;
    input [32-1:0] address;
    reg [32-1:0] result;
begin: MYHDL86_RETURN
    result = 32'h0;
    case (size)
        2'b10: begin
            if ((address[1] == 0)) begin
                if ((address[0] == 0)) begin
                    result = data[32-1:24];
                end
                else begin
                    result = data[24-1:16];
                end
            end
            else begin
                if ((address[0] == 0)) begin
                    result = data[16-1:8];
                end
                else begin
                    result = data[8-1:0];
                end
            end
        end
        2'b01: begin
            if ((address[1] == 0)) begin
                result = data[32-1:16];
            end
            else begin
                result = data[16-1:0];
            end
        end
        default: begin
            result = data;
        end
    endcase
    MYHDL35_align_mem_load = result;
    disable MYHDL86_RETURN;
end
endfunction

function MYHDL36_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL87_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL36_forward_condition = result;
    disable MYHDL87_RETURN;
end
endfunction

function MYHDL37_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL88_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL37_forward_condition = result;
    disable MYHDL88_RETURN;
end
endfunction

function MYHDL38_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL89_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL38_forward_condition = result;
    disable MYHDL89_RETURN;
end
endfunction

function MYHDL39_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL90_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL39_forward_condition = result;
    disable MYHDL90_RETURN;
end
endfunction

function MYHDL40_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL91_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL40_forward_condition = result;
    disable MYHDL91_RETURN;
end
endfunction

function [32-1:0] MYHDL41_align_mem_store;
    input [32-1:0] data;
    input [2-1:0] size;
    reg [32-1:0] result;
begin: MYHDL92_RETURN
    result = 32'h0;
    case (size)
        2'b10: begin
            result = {data[8-1:0], data[8-1:0], data[8-1:0], data[8-1:0]};
        end
        2'b01: begin
            result = {data[16-1:0], data[16-1:0]};
        end
        default: begin
            result = data;
        end
    endcase
    MYHDL41_align_mem_store = result;
    disable MYHDL92_RETURN;
end
endfunction

function MYHDL42_forward_condition;
    input [1-1:0] reg_write;
    input [5-1:0] reg_a;
    input [5-1:0] reg_d;
    reg result;
begin: MYHDL93_RETURN
    result = (reg_write && (reg_a == reg_d));
    MYHDL42_forward_condition = result;
    disable MYHDL93_RETURN;
end
endfunction

function [32-1:0] MYHDL43_align_mem_store;
    input [32-1:0] data;
    input [2-1:0] size;
    reg [32-1:0] result;
begin: MYHDL94_RETURN
    result = 32'h0;
    case (size)
        2'b10: begin
            result = {data[8-1:0], data[8-1:0], data[8-1:0], data[8-1:0]};
        end
        2'b01: begin
            result = {data[16-1:0], data[16-1:0]};
        end
        default: begin
            result = data;
        end
    endcase
    MYHDL43_align_mem_store = result;
    disable MYHDL94_RETURN;
end
endfunction

function [32-1:0] MYHDL44_align_mem_store;
    input [32-1:0] data;
    input [2-1:0] size;
    reg [32-1:0] result;
begin: MYHDL95_RETURN
    result = 32'h0;
    case (size)
        2'b10: begin
            result = {data[8-1:0], data[8-1:0], data[8-1:0], data[8-1:0]};
        end
        2'b01: begin
            result = {data[16-1:0], data[16-1:0]};
        end
        default: begin
            result = data;
        end
    endcase
    MYHDL44_align_mem_store = result;
    disable MYHDL95_RETURN;
end
endfunction

function [33-1:0] MYHDL45_add;
    input [32-1:0] a;
    input [32-1:0] b;
    input ci;
    reg [34-1:0] aa;
    reg [34-1:0] cc;
    reg [33-1:0] result;
    reg [34-1:0] bb;
begin: MYHDL96_RETURN
    aa = 34'h0;
    bb = 34'h0;
    cc = 34'h0;
    result = 33'h0;
    aa = {1'b0, a, 1'b1};
    bb = {1'b0, b, ci};
    cc = ($signed(aa) + $signed(bb));
    result = cc[(32 + 2)-1:1];
    MYHDL45_add = result;
    disable MYHDL96_RETURN;
end
endfunction

function [32-1:0] MYHDL49_sign_extend8;
    input [32-1:0] value;
    input fill;
    reg [32-1:0] tmp;
    integer i;
    integer size;
begin: MYHDL97_RETURN
    tmp = 32'h0;
    size = (32 - 8);
    for (i=0; i<size; i=i+1) begin
        tmp[((32 - 1) - i)] = fill;
    end
    tmp[8-1:0] = value[8-1:0];
    MYHDL49_sign_extend8 = tmp;
    disable MYHDL97_RETURN;
end
endfunction

function [32-1:0] MYHDL55_sign_extend16;
    input [32-1:0] value;
    input fill;
    reg [32-1:0] tmp;
    integer i;
    integer size;
begin: MYHDL98_RETURN
    tmp = 32'h0;
    size = (32 - 16);
    for (i=0; i<size; i=i+1) begin
        tmp[((32 - 1) - i)] = fill;
    end
    tmp[16-1:0] = value[16-1:0];
    MYHDL55_sign_extend16 = tmp;
    disable MYHDL98_RETURN;
end
endfunction

function [4-1:0] MYHDL63_decode_mem_store;
    input [32-1:0] address;
    input [2-1:0] size;
    reg [4-1:0] result;
begin: MYHDL99_RETURN
    result = 4'h0;
    case (size)
        2'b10: begin
            if ((address[1] == 0)) begin
                if ((address[0] == 0)) begin
                    result = 8;
                end
                else begin
                    result = 4;
                end
            end
            else begin
                if ((address[0] == 0)) begin
                    result = 2;
                end
                else begin
                    result = 1;
                end
            end
        end
        2'b01: begin
            if ((address[1] == 0)) begin
                result = 12;
            end
            else begin
                result = 3;
            end
        end
        default: begin
            result = 15;
        end
    endcase
    MYHDL63_decode_mem_store = result;
    disable MYHDL99_RETURN;
end
endfunction


always @(posedge clock) begin: SYSTOP_IMEM_BANK_0_LOGIC
    if (imem_ena_out) begin
        if (imem_bank_wre[0]) begin
            imem_bank_0_ram[imem_bank_addr] <= imem_bank_in[0];
        end
        imem_bank_out[0] <= imem_bank_0_ram[(imem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom0.vmem", imem_bank_0_ram);
    

always @(posedge clock) begin: SYSTOP_IMEM_BANK_1_LOGIC
    if (imem_ena_out) begin
        if (imem_bank_wre[1]) begin
            imem_bank_1_ram[imem_bank_addr] <= imem_bank_in[1];
        end
        imem_bank_out[1] <= imem_bank_1_ram[(imem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom1.vmem", imem_bank_1_ram);
    

always @(posedge clock) begin: SYSTOP_IMEM_BANK_2_LOGIC
    if (imem_ena_out) begin
        if (imem_bank_wre[2]) begin
            imem_bank_2_ram[imem_bank_addr] <= imem_bank_in[2];
        end
        imem_bank_out[2] <= imem_bank_2_ram[(imem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom2.vmem", imem_bank_2_ram);
    

always @(posedge clock) begin: SYSTOP_IMEM_BANK_3_LOGIC
    if (imem_ena_out) begin
        if (imem_bank_wre[3]) begin
            imem_bank_3_ram[imem_bank_addr] <= imem_bank_in[3];
        end
        imem_bank_out[3] <= imem_bank_3_ram[(imem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom3.vmem", imem_bank_3_ram);
    

always @(imem_sel_out, imem_bank_out[0], imem_bank_out[1], imem_bank_out[2], imem_bank_out[3], imem_data_out, imem_addr_out) begin: SYSTOP_IMEM_REASSEMBLE
    integer i;
    imem_bank_addr = imem_addr_out[16-1:2];
    for (i=0; i<4; i=i+1) begin
        imem_bank_wre[i] = imem_sel_out[i];
    end
    imem_bank_in[0] = imem_data_out[8-1:0];
    imem_bank_in[1] = imem_data_out[16-1:8];
    imem_bank_in[2] = imem_data_out[24-1:16];
    imem_bank_in[3] = imem_data_out[32-1:24];
    imem_data_in = {imem_bank_out[3], imem_bank_out[2], imem_bank_out[1], imem_bank_out[0]};
end


always @(posedge clock) begin: SYSTOP_DMEM_BANK_0_LOGIC
    if (dmem_ena) begin
        if (dmem_bank_wre[0]) begin
            dmem_bank_0_ram[dmem_bank_addr] <= dmem_bank_in[0];
        end
        dmem_bank_out[0] <= dmem_bank_0_ram[(dmem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom0.vmem", dmem_bank_0_ram);
    

always @(posedge clock) begin: SYSTOP_DMEM_BANK_1_LOGIC
    if (dmem_ena) begin
        if (dmem_bank_wre[1]) begin
            dmem_bank_1_ram[dmem_bank_addr] <= dmem_bank_in[1];
        end
        dmem_bank_out[1] <= dmem_bank_1_ram[(dmem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom1.vmem", dmem_bank_1_ram);
    

always @(posedge clock) begin: SYSTOP_DMEM_BANK_2_LOGIC
    if (dmem_ena) begin
        if (dmem_bank_wre[2]) begin
            dmem_bank_2_ram[dmem_bank_addr] <= dmem_bank_in[2];
        end
        dmem_bank_out[2] <= dmem_bank_2_ram[(dmem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom2.vmem", dmem_bank_2_ram);
    

always @(posedge clock) begin: SYSTOP_DMEM_BANK_3_LOGIC
    if (dmem_ena) begin
        if (dmem_bank_wre[3]) begin
            dmem_bank_3_ram[dmem_bank_addr] <= dmem_bank_in[3];
        end
        dmem_bank_out[3] <= dmem_bank_3_ram[(dmem_bank_addr % 2048)];
    end
end



    initial $readmemh("rom3.vmem", dmem_bank_3_ram);
    

always @(dmem_sel, dmem_bank_out[0], dmem_bank_out[1], dmem_bank_out[2], dmem_bank_out[3], dmem_data_out, dmem_addr_out) begin: SYSTOP_DMEM_REASSEMBLE
    integer i;
    dmem_bank_addr = dmem_addr_out[32-1:2];
    for (i=0; i<4; i=i+1) begin
        dmem_bank_wre[i] = dmem_sel[i];
    end
    dmem_bank_in[0] = dmem_data_out[8-1:0];
    dmem_bank_in[1] = dmem_data_out[16-1:8];
    dmem_bank_in[2] = dmem_data_out[24-1:16];
    dmem_bank_in[3] = dmem_data_out[32-1:24];
    dmem_data_in = {dmem_bank_out[3], dmem_bank_out[2], dmem_bank_out[1], dmem_bank_out[0]};
end


always @(posedge clock) begin: SYSTOP_CORE_FTCH_SEQ
    if (reset) begin
        core_ftch_if_r_program_counter <= 0;
    end
    else if (dmem_ena_in) begin
        core_ftch_if_r_program_counter <= core_ftch_if_comb_r_program_counter;
    end
end



assign imem_ena_out = dmem_ena_in;
assign imem_addr_out = core_ftch_if_comb_r_program_counter;
assign core_if_program_counter = core_ftch_if_r_program_counter;


always @(reset, core_ex_alu_result, core_ex_branch, core_ftch_if_r_program_counter, core_of_hazard) begin: SYSTOP_CORE_FTCH_COMB
    reg [16-1:0] program_counter;
    program_counter = 16'h0;
    if (reset) begin
        program_counter = 0;
    end
    else if (core_of_hazard) begin
        program_counter = core_ftch_if_r_program_counter;
    end
    else if (core_ex_branch) begin
        program_counter = core_ex_alu_result[16-1:0];
    end
    else begin
        program_counter = ((core_ftch_if_r_program_counter + 4) % 65536);
    end
    core_ftch_if_comb_r_program_counter = program_counter;
end


always @(posedge clock) begin: SYSTOP_CORE_DECO_GPRF_A_LOGIC
    if (dmem_ena_in) begin
        if (core_mm_reg_write) begin
            core_deco_gprf_a_ram[core_mm_reg_d] <= core_deco_wb_dat_d;
        end
        core_gprf_dat_a <= core_deco_gprf_a_ram[core_deco_of_comb_reg_a];
    end
end


always @(posedge clock) begin: SYSTOP_CORE_DECO_GPRF_D_LOGIC
    if (dmem_ena_in) begin
        if (core_mm_reg_write) begin
            core_deco_gprf_d_ram[core_mm_reg_d] <= core_deco_wb_dat_d;
        end
        core_gprf_dat_d <= core_deco_gprf_d_ram[core_deco_of_comb_r_reg_d];
    end
end


always @(posedge clock) begin: SYSTOP_CORE_DECO_GPRF_B_LOGIC
    if (dmem_ena_in) begin
        if (core_mm_reg_write) begin
            core_deco_gprf_b_ram[core_mm_reg_d] <= core_deco_wb_dat_d;
        end
        core_gprf_dat_b <= core_deco_gprf_b_ram[core_deco_of_comb_reg_b];
    end
end


always @(posedge clock) begin: SYSTOP_CORE_DECO_DECODE
    if (reset) begin
        core_of_alu_op <= 4'b0000;
        core_of_alu_src_a <= 2'b00;
        core_of_alu_src_b <= 2'b00;
        core_of_branch_cond <= 3'b111;
        core_of_carry <= 2'b00;
        core_of_carry_keep <= 1'b0;
        core_of_delay <= 1'b0;
        core_of_immediate <= 0;
        core_of_mem_write <= 1'b0;
        core_of_operation <= 1'b0;
        core_of_program_counter <= 0;
        core_of_reg_a <= 0;
        core_of_reg_b <= 0;
        core_of_reg_write <= 1'b0;
        core_of_transfer_size <= 2'b00;
        core_deco_of_r_mem_read <= 1'b0;
        core_deco_of_r_reg_d <= 0;
        core_deco_of_r_hazard <= 1'b0;
        core_deco_of_r_has_imm_high <= 1'b0;
        core_deco_of_r_immediate_high <= 0;
        core_deco_of_r_instruction <= 0;
        core_deco_of_r_program_counter <= 0;
        core_of_fwd_mem_result <= 0;
        core_of_fwd_reg_d <= 0;
        core_of_fwd_reg_write <= 1'b0;
    end
    else if (dmem_ena_in) begin
        core_of_alu_op <= core_deco_of_comb_alu_op;
        core_of_alu_src_a <= core_deco_of_comb_alu_src_a;
        core_of_alu_src_b <= core_deco_of_comb_alu_src_b;
        core_of_branch_cond <= core_deco_of_comb_branch_cond;
        core_of_carry <= core_deco_of_comb_carry;
        core_of_carry_keep <= core_deco_of_comb_carry_keep;
        core_of_delay <= core_deco_of_comb_delay;
        core_of_immediate <= core_deco_of_comb_immediate;
        core_of_mem_write <= core_deco_of_comb_mem_write;
        core_of_operation <= core_deco_of_comb_operation;
        core_of_program_counter <= core_deco_of_comb_program_counter;
        core_of_reg_a <= core_deco_of_comb_reg_a;
        core_of_reg_b <= core_deco_of_comb_reg_b;
        core_of_reg_write <= core_deco_of_comb_reg_write;
        core_of_transfer_size <= core_deco_of_comb_transfer_size;
        core_deco_of_r_mem_read <= core_deco_of_comb_r_mem_read;
        core_deco_of_r_reg_d <= core_deco_of_comb_r_reg_d;
        core_deco_of_r_hazard <= core_deco_of_comb_r_hazard;
        core_deco_of_r_has_imm_high <= core_deco_of_comb_r_has_imm_high;
        core_deco_of_r_immediate_high <= core_deco_of_comb_r_immediate_high;
        core_deco_of_r_instruction <= core_deco_of_comb_r_instruction;
        core_deco_of_r_program_counter <= core_deco_of_comb_r_program_counter;
        core_of_fwd_mem_result <= core_deco_wb_dat_d;
        core_of_fwd_reg_d <= core_mm_reg_d;
        core_of_fwd_reg_write <= core_mm_reg_write;
    end
end


always @(core_deco_of_r_mem_read, core_deco_of_r_reg_d, core_deco_of_r_hazard) begin: SYSTOP_CORE_DECO_REGOUT
    core_of_hazard = core_deco_of_r_hazard;
    core_of_mem_read = core_deco_of_r_mem_read;
    core_of_reg_d = core_deco_of_r_reg_d;
    
end


always @(core_deco_of_r_mem_read, core_deco_of_r_reg_d, core_deco_of_r_immediate_high, core_ex_flush_id, dmem_data_in, core_deco_of_r_instruction, imem_data_in, core_mm_alu_result, core_deco_of_r_has_imm_high, core_deco_of_r_program_counter, core_deco_of_r_hazard, core_if_program_counter, core_mm_mem_read, core_mm_transfer_size) begin: SYSTOP_CORE_DECO_COMB
    reg [2-1:0] transfer_size;
    reg [5-1:0] reg_b;
    reg [5-1:0] reg_a;
    reg reg_write;
    reg [32-1:0] r_instruction;
    reg [2-1:0] carry;
    reg operation;
    reg [32-1:0] mem_result;
    reg delay;
    reg has_imm;
    reg r_has_imm_high;
    reg carry_keep;
    reg [16-1:0] r_program_counter;
    reg [4-1:0] alu_op;
    reg r_hazard;
    reg [3-1:0] branch_cond;
    reg [32-1:0] immediate;
    reg [16-1:0] immediate_low;
    reg [16-1:0] program_counter;
    reg mem_write;
    reg [2-1:0] alu_src_b;
    reg [2-1:0] alu_src_a;
    reg [5-1:0] r_reg_d;
    reg [5-1:0] opgroup;
    reg [32-1:0] instruction;
    reg r_mem_read;
    reg [16-1:0] r_immediate_high;
    reg [6-1:0] opcode;
    r_instruction = 32'h0;
    r_instruction = imem_data_in;
    r_program_counter = 16'h0;
    r_program_counter = core_if_program_counter;
    r_immediate_high = 16'h0;
    r_has_imm_high = 1'b0;
    r_reg_d = 5'h0;
    r_hazard = 1'b0;
    immediate = 32'h0;
    immediate_low = 16'h0;
    instruction = 32'h0;
    mem_result = 32'h0;
    opcode = 6'h0;
    opgroup = 5'h0;
    program_counter = 16'h0;
    reg_a = 5'h0;
    reg_b = 5'h0;
    if (core_mm_mem_read) begin
        mem_result = MYHDL24_align_mem_load(dmem_data_in, core_mm_transfer_size, core_mm_alu_result[2-1:0]);
    end
    else begin
        mem_result = core_mm_alu_result;
    end
    core_deco_wb_dat_d = mem_result;
    if (((!core_ex_flush_id) && core_deco_of_r_mem_read && ((imem_data_in[21-1:16] == core_deco_of_r_reg_d) || (imem_data_in[16-1:11] == core_deco_of_r_reg_d)))) begin
        instruction = 0;
        program_counter = 0;
        r_hazard = 1'b1;
    end
    else if (((!core_ex_flush_id) && core_deco_of_r_mem_read && (imem_data_in[26-1:21] == core_deco_of_r_reg_d))) begin
        instruction = 0;
        program_counter = 0;
        r_hazard = 1'b1;
    end
    else if (core_deco_of_r_hazard) begin
        instruction = core_deco_of_r_instruction;
        program_counter = core_deco_of_r_program_counter;
        r_hazard = 1'b0;
    end
    else begin
        instruction = imem_data_in;
        program_counter = core_if_program_counter;
        r_hazard = 1'b0;
    end
    opgroup = {instruction[32-1:30], instruction[29-1:26]};
    opcode = instruction[32-1:26];
    has_imm = opcode[3];
    immediate_low = instruction[16-1:0];
    reg_a = instruction[21-1:16];
    reg_b = instruction[16-1:11];
    r_reg_d = instruction[26-1:21];
    if (core_deco_of_r_has_imm_high) begin
        immediate = {core_deco_of_r_immediate_high, immediate_low};
    end
    else begin
        immediate = MYHDL25_sign_extend16(immediate_low, immediate_low[15]);
    end
    alu_op = 4'b0000;
    alu_src_a = 2'b00;
    alu_src_b = 2'b00;
    branch_cond = 3'b111;
    carry = 2'b00;
    carry_keep = 1'b0;
    delay = 1'b0;
    r_mem_read = 1'b0;
    mem_write = 1'b0;
    operation = 1'b0;
    reg_write = 1'b0;
    transfer_size = 2'b00;
    if (((core_ex_flush_id || r_hazard) != 0)) begin
        // pass
    end
    else if ((opgroup[5-1:3] == 0)) begin
        alu_op = 4'b0000;
        if (opcode[0]) begin
            alu_src_a = 2'b01;
        end
        if (((opcode == 5) && instruction[1])) begin
            operation = 1'b1;
        end
        if (has_imm) begin
            alu_src_b = 2'b10;
        end
        else begin
            alu_src_b = 2'b00;
        end
        if ((opcode[2-1:0] == 0)) begin
            carry = 2'b00;
        end
        else if ((opcode[2-1:0] == 1)) begin
            carry = 2'b01;
        end
        else begin
            carry = 2'b10;
        end
        carry_keep = opcode[2];
        reg_write = (!(r_reg_d == 0));
    end
    else if ((opgroup[5-1:2] == 4)) begin
        if ((opcode[2-1:0] == 0)) begin
            alu_op = 4'b0001;
        end
        else if ((opcode[2-1:0] == 2)) begin
            alu_op = 4'b0011;
        end
        else begin
            alu_op = 4'b0010;
        end
        if ((has_imm && (opcode[2-1:0] == 3))) begin
            alu_src_b = 2'b11;
        end
        else if (has_imm) begin
            alu_src_b = 2'b10;
        end
        else if (((!has_imm) && (opcode[2-1:0] == 3))) begin
            alu_src_b = 2'b01;
        end
        else begin
            alu_src_b = 2'b00;
        end
        reg_write = (!(r_reg_d == 0));
    end
    else if ((opcode == 44)) begin
        r_immediate_high = instruction[16-1:0];
        r_has_imm_high = 1'b1;
    end
    else if ((opcode == 36)) begin
        if ((instruction[7-1:5] == 3)) begin
            if (instruction[0]) begin
                alu_op = 4'b0110;
            end
            else begin
                alu_op = 4'b0101;
            end
        end
        else begin
            alu_op = 4'b0100;
            carry_keep = 1'b0;
            if ((instruction[7-1:5] == 2)) begin
                carry = 2'b00;
            end
            else if ((instruction[7-1:5] == 1)) begin
                carry = 2'b10;
            end
            else begin
                carry = 2'b11;
            end
        end
        reg_write = (!(r_reg_d == 0));
    end
    else if ((opgroup == 22)) begin
        branch_cond = 3'b110;
        if (has_imm) begin
            alu_src_b = 2'b10;
        end
        else begin
            alu_src_b = 2'b00;
        end
        if (reg_a[2]) begin
            reg_write = (!(r_reg_d == 0));
        end
        if (reg_a[3]) begin
            alu_src_a = 2'b11;
        end
        else begin
            alu_src_a = 2'b10;
        end
        delay = reg_a[4];
    end
    else if ((opgroup == 23)) begin
        alu_op = 4'b0000;
        alu_src_a = 2'b10;
        if (has_imm) begin
            alu_src_b = 2'b10;
        end
        else begin
            alu_src_b = 2'b00;
        end
        if ((r_reg_d[3-1:0] == 0)) begin
            branch_cond = 3'b000;
        end
        else if ((r_reg_d[3-1:0] == 1)) begin
            branch_cond = 3'b001;
        end
        else if ((r_reg_d[3-1:0] == 2)) begin
            branch_cond = 3'b010;
        end
        else if ((r_reg_d[3-1:0] == 3)) begin
            branch_cond = 3'b011;
        end
        else if ((r_reg_d[3-1:0] == 4)) begin
            branch_cond = 3'b100;
        end
        else begin
            branch_cond = 3'b101;
        end
        delay = r_reg_d[4];
    end
    else if ((opcode == 45)) begin
        branch_cond = 3'b110;
        alu_src_b = 2'b10;
        delay = 1'b1;
    end
    else if ((opgroup[5-1:3] == 3)) begin
        alu_op = 4'b0000;
        alu_src_a = 2'b00;
        if (has_imm) begin
            alu_src_b = 2'b10;
        end
        else begin
            alu_src_b = 2'b00;
        end
        carry = 2'b00;
        if (opcode[2]) begin
            mem_write = 1'b1;
            r_mem_read = 1'b0;
            reg_write = 1'b0;
        end
        else begin
            mem_write = 1'b0;
            r_mem_read = 1'b1;
            reg_write = (!(r_reg_d == 0));
        end
        if ((opcode[2-1:0] == 0)) begin
            transfer_size = 2'b10;
        end
        else if ((opcode[2-1:0] == 1)) begin
            transfer_size = 2'b01;
        end
        else begin
            transfer_size = 2'b00;
        end
        delay = 1'b0;
    end
    else begin
        // pass
    end
    core_deco_of_comb_r_has_imm_high = r_has_imm_high;
    core_deco_of_comb_r_immediate_high = r_immediate_high;
    core_deco_of_comb_r_instruction = r_instruction;
    core_deco_of_comb_r_program_counter = r_program_counter;
    core_deco_of_comb_r_hazard = r_hazard;
    core_deco_of_comb_r_mem_read = r_mem_read;
    core_deco_of_comb_r_reg_d = r_reg_d;
    core_deco_of_comb_alu_op = alu_op;
    core_deco_of_comb_alu_src_a = alu_src_a;
    core_deco_of_comb_alu_src_b = alu_src_b;
    core_deco_of_comb_branch_cond = branch_cond;
    core_deco_of_comb_carry = carry;
    core_deco_of_comb_carry_keep = carry_keep;
    core_deco_of_comb_delay = delay;
    core_deco_of_comb_immediate = immediate;
    core_deco_of_comb_mem_write = mem_write;
    core_deco_of_comb_operation = operation;
    core_deco_of_comb_program_counter = program_counter;
    core_deco_of_comb_reg_a = reg_a;
    core_deco_of_comb_reg_b = reg_b;
    core_deco_of_comb_reg_write = reg_write;
    core_deco_of_comb_transfer_size = transfer_size;
end

// ExecUnit combinatorial logic
always @(core_gprf_dat_d, core_of_reg_write, dmem_data_in, core_gprf_dat_a, core_gprf_dat_b, core_of_transfer_size, core_of_fwd_reg_d, core_exeu_ex_r_flush_ex, core_of_carry, core_of_program_counter, core_mm_transfer_size, core_of_fwd_reg_write, core_of_alu_src_a, core_exeu_ex_r_reg_write, core_mm_mem_read, core_of_alu_src_b, core_of_delay, core_of_fwd_mem_result, core_mm_alu_result, core_of_mem_read, core_mm_reg_d, core_of_reg_d, core_of_reg_a, core_of_reg_b, core_of_operation, core_exeu_ex_r_alu_result, core_exeu_ex_r_reg_d, core_of_immediate, core_exeu_ex_r_carry, core_of_mem_write, core_mm_reg_write, core_of_branch_cond, core_of_alu_op, core_of_carry_keep) begin: SYSTOP_CORE_EXEU_COMB
    reg [2-1:0] transfer_size;
    reg [32-1:0] dat_a;
    reg [32-1:0] xor_rslt;
    reg zero;
    reg [33-1:0] result;
    reg carry;
    reg flush_id;
    reg [32-1:0] or_rslt;
    reg r_carry;
    reg [32-1:0] mem_result;
    reg r_flush_ex;
    reg [32-1:0] sel_dat_b;
    reg [32-1:0] sel_dat_a;
    reg [32-1:0] r_alu_result;
    reg branch;
    integer cmp_cond;
    reg msb;
    reg [32-1:0] sel_dat_d;
    reg mem_write;
    reg [16-1:0] program_counter;
    reg [32-1:0] dat_d;
    reg [32-1:0] dat_b;
    reg r_reg_write;
    reg [32-1:0] alu_src_b;
    reg [32-1:0] alu_src_a;
    reg [5-1:0] r_reg_d;
    reg [32-1:0] and_rslt;
    reg mem_read;
    reg [33-1:0] result_add;
    r_carry = 1'b0;
    r_flush_ex = 1'b0;
    r_alu_result = 32'h0;
    r_reg_d = 5'h0;
    r_reg_write = 1'b0;
    branch = 1'b0;
    dat_d = 32'h0;
    flush_id = 1'b0;
    mem_read = 1'b0;
    mem_write = 1'b0;
    program_counter = 16'h0;
    transfer_size = 2'b00;
    alu_src_a = 32'h0;
    alu_src_b = 32'h0;
    carry = 1'b0;
    result = 33'h0;
    result_add = 33'h0;
    zero = 1'b0;
    dat_a = 32'h0;
    dat_b = 32'h0;
    sel_dat_a = 32'h0;
    sel_dat_b = 32'h0;
    sel_dat_d = 32'h0;
    mem_result = 32'h0;
    sel_dat_a = MYHDL30_select_register_data(core_gprf_dat_a, core_of_reg_a, core_of_fwd_mem_result, MYHDL29_forward_condition(core_of_fwd_reg_write, core_of_fwd_reg_d, core_of_reg_a));
    sel_dat_b = MYHDL32_select_register_data(core_gprf_dat_b, core_of_reg_b, core_of_fwd_mem_result, MYHDL31_forward_condition(core_of_fwd_reg_write, core_of_fwd_reg_d, core_of_reg_b));
    sel_dat_d = MYHDL34_select_register_data(core_gprf_dat_d, core_of_reg_d, core_of_fwd_mem_result, MYHDL33_forward_condition(core_of_fwd_reg_write, core_of_fwd_reg_d, core_of_reg_d));
    if ((!core_exeu_ex_r_flush_ex)) begin
        mem_write = (core_of_mem_write != 0);
        mem_read = (core_of_mem_read != 0);
        transfer_size = core_of_transfer_size;
        r_reg_write = (core_of_reg_write != 0);
        r_reg_d = core_of_reg_d;
    end
    if (core_mm_mem_read) begin
        mem_result = MYHDL35_align_mem_load(dmem_data_in, core_mm_transfer_size, core_mm_alu_result[2-1:0]);
    end
    else begin
        mem_result = core_mm_alu_result;
    end
    if ((MYHDL36_forward_condition(core_exeu_ex_r_reg_write, core_exeu_ex_r_reg_d, core_of_reg_a) == 1'b1)) begin
        dat_a = core_exeu_ex_r_alu_result;
    end
    else if ((MYHDL37_forward_condition(core_mm_reg_write, core_mm_reg_d, core_of_reg_a) == 1'b1)) begin
        dat_a = mem_result;
    end
    else begin
        dat_a = sel_dat_a;
    end
    if ((MYHDL38_forward_condition(core_exeu_ex_r_reg_write, core_exeu_ex_r_reg_d, core_of_reg_b) == 1'b1)) begin
        dat_b = core_exeu_ex_r_alu_result;
    end
    else if ((MYHDL39_forward_condition(core_mm_reg_write, core_mm_reg_d, core_of_reg_b) == 1'b1)) begin
        dat_b = mem_result;
    end
    else begin
        dat_b = sel_dat_b;
    end
    if ((MYHDL40_forward_condition(core_exeu_ex_r_reg_write, core_exeu_ex_r_reg_d, core_of_reg_d) == 1'b1)) begin
        dat_d = MYHDL41_align_mem_store(core_exeu_ex_r_alu_result, core_of_transfer_size);
    end
    else if ((MYHDL42_forward_condition(core_mm_reg_write, core_mm_reg_d, core_of_reg_d) == 1'b1)) begin
        dat_d = MYHDL43_align_mem_store(mem_result, core_of_transfer_size);
    end
    else begin
        dat_d = MYHDL44_align_mem_store(sel_dat_d, core_of_transfer_size);
    end
    case (core_of_alu_src_a)
        2'b10: begin
            alu_src_a = core_of_program_counter;
        end
        2'b01: begin
            alu_src_a = (~dat_a);
        end
        2'b11: begin
            alu_src_a = 0;
        end
        default: begin
            alu_src_a = dat_a;
        end
    endcase
    case (core_of_alu_src_b)
        2'b10: begin
            alu_src_b = core_of_immediate;
        end
        2'b11: begin
            alu_src_b = (~core_of_immediate);
        end
        2'b01: begin
            alu_src_b = (~dat_b);
        end
        default: begin
            alu_src_b = dat_b;
        end
    endcase
    case (core_of_carry)
        2'b10: begin
            carry = (core_exeu_ex_r_carry != 0);
        end
        2'b01: begin
            carry = 1'b1;
        end
        2'b11: begin
            carry = alu_src_a[(32 - 1)];
        end
        default: begin
            carry = 1'b0;
        end
    endcase
    result_add = MYHDL45_add(alu_src_a, alu_src_b, carry);
    case (core_of_alu_op)
        4'b0000: begin
            result = result_add;
        end
        4'b0001: begin
            or_rslt = 32'h0;
            or_rslt = (alu_src_a | alu_src_b);
            result = or_rslt;
        end
        4'b0010: begin
            and_rslt = 32'h0;
            and_rslt = (alu_src_a & alu_src_b);
            result = and_rslt;
        end
        4'b0011: begin
            xor_rslt = 32'h0;
            xor_rslt = (alu_src_a ^ alu_src_b);
            result = xor_rslt;
        end
        4'b0100: begin
            result = {alu_src_a[0], carry, alu_src_a[32-1:1]};
        end
        4'b0101: begin
            result = {1'b0, MYHDL49_sign_extend8(alu_src_a, alu_src_a[7])};
        end
        4'b0110: begin
            result = {1'b0, MYHDL55_sign_extend16(alu_src_a, alu_src_a[15])};
        end
        default: begin
            result = 0;
            
        end
    endcase
    if (core_of_carry_keep) begin
        r_carry = (core_exeu_ex_r_carry != 0);
    end
    else begin
        r_carry = result[32];
    end
    if ((!core_exeu_ex_r_flush_ex)) begin
        zero = (dat_a == 0);
        case (core_of_branch_cond)
            3'b110: begin
                branch = 1'b1;
            end
            3'b000: begin
                branch = zero;
            end
            3'b001: begin
                branch = (!zero);
            end
            3'b010: begin
                branch = dat_a[(32 - 1)];
            end
            3'b011: begin
                branch = (dat_a[(32 - 1)] || zero);
            end
            3'b100: begin
                branch = (!((dat_a[(32 - 1)] || zero) != 0));
            end
            3'b101: begin
                branch = (!dat_a[(32 - 1)]);
            end
            default: begin
                branch = 1'b0;
            end
        endcase
    end
    cmp_cond = (alu_src_a[(32 - 1)] ^ alu_src_b[(32 - 1)]);
    if ((core_of_operation && (cmp_cond != 0))) begin
        msb = alu_src_a[(32 - 1)];
        r_alu_result = {msb, result[(32 - 1)-1:0]};
    end
    else begin
        r_alu_result = result[32-1:0];
    end
    program_counter = core_of_program_counter;
    flush_id = branch;
    r_flush_ex = (branch && (!core_of_delay));
    core_exeu_ex_comb_r_carry = r_carry;
    core_exeu_ex_comb_r_flush_ex = r_flush_ex;
    core_exeu_ex_comb_r_alu_result = r_alu_result;
    core_exeu_ex_comb_r_reg_d = r_reg_d;
    core_exeu_ex_comb_r_reg_write = r_reg_write;
    core_exeu_ex_comb_branch = branch;
    core_exeu_ex_comb_dat_d = dat_d;
    core_exeu_ex_comb_flush_id = flush_id;
    core_exeu_ex_comb_mem_read = mem_read;
    core_exeu_ex_comb_mem_write = mem_write;
    core_exeu_ex_comb_program_counter = program_counter;
    core_exeu_ex_comb_transfer_size = transfer_size;
    
end

// ExecUnit sequential logic
always @(posedge clock) begin: SYSTOP_CORE_EXEU_SEQ
    if (reset) begin
        core_exeu_ex_r_carry <= 1'b0;
        core_exeu_ex_r_flush_ex <= 1'b0;
        core_exeu_ex_r_alu_result <= 32'h0;
        core_exeu_ex_r_reg_d <= 5'h0;
        core_exeu_ex_r_reg_write <= 1'b0;
        core_ex_branch <= 1'b0;
        core_ex_dat_d <= 32'h0;
        core_ex_flush_id <= 1'b0;
        core_ex_mem_read <= 1'b0;
        core_ex_mem_write <= 1'b0;
        core_ex_program_counter <= 16'h0;
        core_ex_transfer_size <= 2'b00;
    end
    else if (dmem_ena_in) begin
        core_exeu_ex_r_carry <= core_exeu_ex_comb_r_carry;
        core_exeu_ex_r_flush_ex <= core_exeu_ex_comb_r_flush_ex;
        core_exeu_ex_r_alu_result <= core_exeu_ex_comb_r_alu_result;
        core_exeu_ex_r_reg_d <= core_exeu_ex_comb_r_reg_d;
        core_exeu_ex_r_reg_write <= core_exeu_ex_comb_r_reg_write;
        core_ex_branch <= core_exeu_ex_comb_branch;
        core_ex_dat_d <= core_exeu_ex_comb_dat_d;
        core_ex_flush_id <= core_exeu_ex_comb_flush_id;
        core_ex_mem_read <= core_exeu_ex_comb_mem_read;
        core_ex_mem_write <= core_exeu_ex_comb_mem_write;
        core_ex_program_counter <= core_exeu_ex_comb_program_counter;
        core_ex_transfer_size <= core_exeu_ex_comb_transfer_size;
    end
    
end



assign core_ex_alu_result = core_exeu_ex_r_alu_result;
assign core_ex_reg_d = core_exeu_ex_r_reg_d;
assign core_ex_reg_write = core_exeu_ex_r_reg_write;


always @(posedge clock) begin: SYSTOP_CORE_MEMU_SEQ
    if (reset) begin
        core_mm_alu_result <= 0;
        core_mm_mem_read <= 1'b0;
        core_mm_reg_d <= 0;
        core_mm_reg_write <= 1'b0;
        core_mm_transfer_size <= 2'b00;
    end
    else if (dmem_ena_in) begin
        core_mm_alu_result <= core_memu_mm_comb_alu_result;
        core_mm_mem_read <= core_memu_mm_comb_mem_read;
        core_mm_reg_d <= core_memu_mm_comb_reg_d;
        core_mm_reg_write <= core_memu_mm_comb_reg_write;
        core_mm_transfer_size <= core_memu_mm_comb_transfer_size;
    end
end


always @(core_ex_dat_d, core_ex_branch, core_ex_reg_d, core_ex_program_counter, core_ex_alu_result, core_ex_mem_read, core_ex_reg_write, core_ex_transfer_size) begin: SYSTOP_CORE_MEMU_COMB
    reg [32-1:0] alu_result;
    alu_result = 32'h0;
    if (core_ex_branch) begin
        alu_result = core_ex_program_counter;
    end
    else begin
        alu_result = core_ex_alu_result;
    end
    core_memu_mem_result = core_ex_dat_d;
    core_memu_mm_comb_alu_result = alu_result;
    core_memu_mm_comb_mem_read = core_ex_mem_read;
    core_memu_mm_comb_reg_d = core_ex_reg_d;
    core_memu_mm_comb_reg_write = core_ex_reg_write;
    core_memu_mm_comb_transfer_size = core_ex_transfer_size;
end



assign dmem_data_out = core_memu_mem_result;
assign dmem_sel_out = MYHDL63_decode_mem_store(core_ex_alu_result[2-1:0], core_ex_transfer_size);
assign dmem_we_out = core_ex_mem_write;
assign dmem_addr_out = core_ex_alu_result[32-1:0];
assign dmem_ena_out = (core_ex_mem_write || core_ex_mem_read);


always @(posedge clock) begin: SYSTOP_UART_RXD_SYNC
    uart_uart_rxd1 <= uart_rxd;
    uart_uart_rxd2 <= uart_uart_rxd1;
end



assign uart_enable16 = (!(uart_enable16_counter != 0));



assign tx_busy = uart_tx_is_busy;


always @(posedge clock) begin: SYSTOP_UART_ENABLE16_TICK
    if ((reset || uart_enable16)) begin
        uart_enable16_counter <= (1 - 1);
    end
    else begin
        uart_enable16_counter <= (uart_enable16_counter - 1);
    end
end


always @(posedge clock) begin: SYSTOP_UART_RECV
    if (reset) begin
        uart_rx_count16 <= 0;
        rx_avail <= 1'b0;
        rx_error <= 1'b0;
        uart_rx_is_busy <= 1'b0;
    end
    else begin
        if (read_en) begin
            rx_avail <= 1'b0;
            rx_error <= 1'b0;
        end
        if (uart_enable16) begin
            if ((!uart_rx_is_busy)) begin
                if ((!uart_uart_rxd2)) begin
                    uart_rx_is_busy <= 1'b1;
                    uart_rx_count16 <= 7;
                    uart_rx_bitcount <= 0;
                end
            end
            else begin
                uart_rx_count16 <= ((uart_rx_count16 + 1) % 16);
                if ((uart_rx_count16 == 0)) begin
                    uart_rx_bitcount <= ((uart_rx_bitcount + 1) % 16);
                    case (uart_rx_bitcount)
                        'h0: begin
                            if (uart_uart_rxd2) begin
                                uart_rx_is_busy <= 1'b0;
                            end
                        end
                        'h9: begin
                            uart_rx_is_busy <= 1'b0;
                            if (uart_uart_rxd2) begin
                                rx_data <= uart_rxd_reg;
                                rx_avail <= 1'b1;
                                rx_error <= 1'b0;
                            end
                            else begin
                                rx_error <= 1'b1;
                            end
                        end
                        default: begin
                            uart_rxd_reg <= {uart_uart_rxd2, uart_rxd_reg[8-1:1]};
                        end
                    endcase
                end
            end
        end
    end
end


always @(posedge clock) begin: SYSTOP_UART_TRANS
    if (reset) begin
        uart_tx_is_busy <= 1'b0;
        uart_txd <= 1;
        uart_tx_count16 <= 0;
    end
    else begin
        if ((write_en && (!uart_tx_is_busy))) begin
            uart_txd_reg <= {tx_data[8-1:0], 1'b0};
            uart_tx_bitcount <= 10;
            uart_tx_count16 <= 0;
            uart_tx_is_busy <= 1'b1;
        end
        if (uart_enable16) begin
            uart_tx_count16 <= ((uart_tx_count16 + 1) % 16);
            if (((uart_tx_count16 == 0) && uart_tx_is_busy)) begin
                if ((uart_tx_bitcount > 0)) begin
                    uart_tx_bitcount <= (uart_tx_bitcount - 1);
                end
                if ((uart_tx_bitcount == 0)) begin
                    uart_tx_is_busy <= 1'b0;
                end
                else begin
                    uart_txd <= uart_txd_reg[0];
                    uart_txd_reg <= {1'b1, uart_txd_reg[9-1:1]};
                end
            end
        end
    end
end


always @(posedge clock) begin: SYSTOP_UART2_RXD_SYNC
    uart2_uart_rxd1 <= uart_rxd2;
    uart2_uart_rxd2 <= uart2_uart_rxd1;
end



assign uart2_enable16 = (!(uart2_enable16_counter != 0));



assign tx_busy2 = uart2_tx_is_busy;


always @(posedge clock) begin: SYSTOP_UART2_ENABLE16_TICK
    if ((reset || uart2_enable16)) begin
        uart2_enable16_counter <= (27 - 1);
    end
    else begin
        uart2_enable16_counter <= (uart2_enable16_counter - 1);
    end
end


always @(posedge clock) begin: SYSTOP_UART2_RECV
    if (reset) begin
        uart2_rx_count16 <= 0;
        rx_avail2 <= 1'b0;
        rx_error2 <= 1'b0;
        uart2_rx_is_busy <= 1'b0;
    end
    else begin
        if (read_en2) begin
            rx_avail2 <= 1'b0;
            rx_error2 <= 1'b0;
        end
        if (uart2_enable16) begin
            if ((!uart2_rx_is_busy)) begin
                if ((!uart2_uart_rxd2)) begin
                    uart2_rx_is_busy <= 1'b1;
                    uart2_rx_count16 <= 7;
                    uart2_rx_bitcount <= 0;
                end
            end
            else begin
                uart2_rx_count16 <= ((uart2_rx_count16 + 1) % 16);
                if ((uart2_rx_count16 == 0)) begin
                    uart2_rx_bitcount <= ((uart2_rx_bitcount + 1) % 16);
                    case (uart2_rx_bitcount)
                        'h0: begin
                            if (uart2_uart_rxd2) begin
                                uart2_rx_is_busy <= 1'b0;
                            end
                        end
                        'h9: begin
                            uart2_rx_is_busy <= 1'b0;
                            if (uart2_uart_rxd2) begin
                                rx_data2 <= uart2_rxd_reg;
                                rx_avail2 <= 1'b1;
                                rx_error2 <= 1'b0;
                            end
                            else begin
                                rx_error2 <= 1'b1;
                            end
                        end
                        default: begin
                            uart2_rxd_reg <= {uart2_uart_rxd2, uart2_rxd_reg[8-1:1]};
                        end
                    endcase
                end
            end
        end
    end
end


always @(posedge clock) begin: SYSTOP_UART2_TRANS
    if (reset) begin
        uart2_tx_is_busy <= 1'b0;
        uart_txd2 <= 1;
        uart2_tx_count16 <= 0;
    end
    else begin
        if ((write_en2 && (!uart2_tx_is_busy))) begin
            uart2_txd_reg <= {tx_data2[8-1:0], 1'b0};
            uart2_tx_bitcount <= 10;
            uart2_tx_count16 <= 0;
            uart2_tx_is_busy <= 1'b1;
        end
        if (uart2_enable16) begin
            uart2_tx_count16 <= ((uart2_tx_count16 + 1) % 16);
            if (((uart2_tx_count16 == 0) && uart2_tx_is_busy)) begin
                if ((uart2_tx_bitcount > 0)) begin
                    uart2_tx_bitcount <= (uart2_tx_bitcount - 1);
                end
                if ((uart2_tx_bitcount == 0)) begin
                    uart2_tx_is_busy <= 1'b0;
                end
                else begin
                    uart_txd2 <= uart2_txd_reg[0];
                    uart2_txd_reg <= {1'b1, uart2_txd_reg[9-1:1]};
                end
            end
        end
    end
end


always @(tx_busy, dmem_we_out, dmem_ena_out, dmem_data_out, dmem_sel_out, led_reg, dmem_addr_out) begin: SYSTOP_GLUE
    dmem_ena_in = 1'b1;
    if (dmem_we_out) begin
        dmem_sel = dmem_sel_out;
    end
    else begin
        dmem_sel = 0;
    end
    tx_data = dmem_data_out;
    if ((dmem_addr_out < (2 ** 13))) begin
        dmem_ena = dmem_ena_out;
        write_en = 1'b0;
    end
    else if ((dmem_we_out && (dmem_addr_out[28-1:0] >= 268435392))) begin
        dmem_ena = 1'b0;
        dmem_ena_in = (!tx_busy);
        write_en = 1'b1;
    end
    else begin
        write_en = 1'b0;
        dmem_ena = 1'b0;
    end
    leds = led_reg[8-1:0];
end


always @(posedge clock) begin: SYSTOP_RUN
    if (reset) begin
        txd_line <= 1'b0;
        txd_line2 <= 1'b0;
        led_reg <= 1;
        led_low <= 1;
        imem_data_out <= 0;
        imem_sel_out <= 0;
        read_en <= 1'b0;
        uart_rxd <= 1;
        read_en2 <= 1'b0;
        uart_rxd2 <= 1;
        count <= 0;
    end
    else begin
        txd_line <= uart_txd;
        uart_rxd <= rxd_line;
        txd_line2 <= uart_txd2;
        uart_rxd2 <= rxd_line2;
        read_en <= 1'b0;
        count <= ((count + 1) % (2 ** 20));
        if ((dmem_we_out && (dmem_addr_out[28-1:0] == 268435376))) begin
            led_reg <= dmem_data_out;
        end
        else begin
            led_reg <= led_reg;
        end
    end
end

endmodule
